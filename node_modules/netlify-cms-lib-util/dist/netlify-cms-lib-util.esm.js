import { fromJS, Map as Map$1, Set, List } from 'immutable';
import localForage from 'localforage';
import zipObject from 'lodash/zipObject';
import curry from 'lodash/curry';
import flow from 'lodash/flow';
import isString from 'lodash/isString';
import _get from 'lodash/get';

function _extendableBuiltin(cls) {
  function ExtendableBuiltin() {
    var instance = Reflect.construct(cls, Array.from(arguments));
    Object.setPrototypeOf(instance, Object.getPrototypeOf(this));
    return instance;
  }

  ExtendableBuiltin.prototype = Object.create(cls.prototype, {
    constructor: {
      value: cls,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });

  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(ExtendableBuiltin, cls);
  } else {
    ExtendableBuiltin.__proto__ = cls;
  }

  return ExtendableBuiltin;
}

const API_ERROR = 'API_ERROR';
class APIError extends _extendableBuiltin(Error) {
  constructor(message, status, api, meta = {}) {
    super(message);
    this.message = message;
    this.status = status;
    this.api = api;
    this.name = API_ERROR;
    this.meta = meta;
  }

}

const jsToMap = obj => {
  if (obj === undefined) {
    return Map$1();
  }

  const immutableObj = fromJS(obj);

  if (!Map$1.isMap(immutableObj)) {
    throw new Error('Object must be equivalent to a Map.');
  }

  return immutableObj;
};

const knownMetaKeys = Set(['index', 'count', 'pageSize', 'pageCount', 'usingOldPaginationAPI']);

const filterUnknownMetaKeys = meta => meta.filter((v, k) => knownMetaKeys.has(k));
/*
  createCursorMap takes one of three signatures:
  - () -> cursor with empty actions, data, and meta
  - (cursorMap: <object/Map with optional actions, data, and meta keys>) -> cursor
  - (actions: <array/List>, data: <object/Map>, meta: <optional object/Map>) -> cursor
*/


const createCursorMap = (...args) => {
  const _ref = args.length === 1 ? jsToMap(args[0]).toObject() : {
    actions: args[0],
    data: args[1],
    meta: args[2]
  },
        actions = _ref.actions,
        data = _ref.data,
        meta = _ref.meta;

  return Map$1({
    // actions are a Set, rather than a List, to ensure an efficient .has
    actions: Set(actions),
    // data and meta are Maps
    data: jsToMap(data),
    meta: jsToMap(meta).update(filterUnknownMetaKeys)
  });
};

const hasAction = (cursorMap, action) => cursorMap.hasIn(['actions', action]);

const getActionHandlers = (cursorMap, handler) => cursorMap.get('actions', Set()).toMap().map(action => handler(action)); // The cursor logic is entirely functional, so this class simply
// provides a chainable interface


class Cursor {
  static create(...args) {
    return new Cursor(...args);
  }

  constructor(...args) {
    if (args[0] instanceof Cursor) {
      return args[0];
    }

    this.store = createCursorMap(...args);
    this.actions = this.store.get('actions');
    this.data = this.store.get('data');
    this.meta = this.store.get('meta');
  }

  updateStore(...args) {
    return new Cursor(this.store.update(...args));
  }

  updateInStore(...args) {
    return new Cursor(this.store.updateIn(...args));
  }

  hasAction(action) {
    return hasAction(this.store, action);
  }

  addAction(action) {
    return this.updateStore('actions', actions => actions.add(action));
  }

  removeAction(action) {
    return this.updateStore('actions', actions => actions.delete(action));
  }

  setActions(actions) {
    return this.updateStore(store => store.set('actions', Set(actions)));
  }

  mergeActions(actions) {
    return this.updateStore('actions', oldActions => oldActions.union(actions));
  }

  getActionHandlers(handler) {
    return getActionHandlers(this.store, handler);
  }

  setData(data) {
    return new Cursor(this.store.set('data', jsToMap(data)));
  }

  mergeData(data) {
    return new Cursor(this.store.mergeIn(['data'], jsToMap(data)));
  }

  wrapData(data) {
    return this.updateStore('data', oldData => jsToMap(data).set('wrapped_cursor_data', oldData));
  }

  unwrapData() {
    return [this.store.get('data').delete('wrapped_cursor_data'), this.updateStore('data', data => data.get('wrapped_cursor_data'))];
  }

  clearData() {
    return this.updateStore('data', () => Map$1());
  }

  setMeta(meta) {
    return this.updateStore(store => store.set('meta', jsToMap(meta)));
  }

  mergeMeta(meta) {
    return this.updateStore(store => store.update('meta', oldMeta => oldMeta.merge(jsToMap(meta))));
  }

} // This is a temporary hack to allow cursors to be added to the
// interface between backend.js and backends without modifying old
// backends at all. This should be removed in favor of wrapping old
// backends with a compatibility layer, as part of the backend API
// refactor.

const CURSOR_COMPATIBILITY_SYMBOL = Symbol('cursor key for compatibility with old backends');

function _extendableBuiltin$1(cls) {
  function ExtendableBuiltin() {
    var instance = Reflect.construct(cls, Array.from(arguments));
    Object.setPrototypeOf(instance, Object.getPrototypeOf(this));
    return instance;
  }

  ExtendableBuiltin.prototype = Object.create(cls.prototype, {
    constructor: {
      value: cls,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });

  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(ExtendableBuiltin, cls);
  } else {
    ExtendableBuiltin.__proto__ = cls;
  }

  return ExtendableBuiltin;
}

const EDITORIAL_WORKFLOW_ERROR = 'EDITORIAL_WORKFLOW_ERROR';
class EditorialWorkflowError extends _extendableBuiltin$1(Error) {
  constructor(message, notUnderEditorialWorkflow) {
    super(message);
    this.message = message;
    this.notUnderEditorialWorkflow = notUnderEditorialWorkflow;
    this.name = EDITORIAL_WORKFLOW_ERROR;
  }

}

function localForageTest() {
  const testKey = 'localForageTest';
  localForage.setItem(testKey, {
    expires: Date.now() + 300000
  }).then(() => {
    localForage.removeItem(testKey);
  }).catch(err => {
    if (err.code === 22) {
      const message = 'Unable to set localStorage key. Quota exceeded! Full disk?';
      console.warn(message);
    }

    console.log(err);
  });
}

localForageTest();

const absolutePath = new RegExp('^(?:[a-z]+:)?//', 'i');

const normalizePath = path => path.replace(/[\\/]+/g, '/');

function resolvePath(path, basePath) {
  // No path provided, skip
  if (!path) return null; // It's an absolute path.

  if (absolutePath.test(path)) return path;

  if (path.indexOf('/') === -1) {
    // It's a single file name, no directories. Prepend public folder
    return normalizePath(`/${basePath}/${path}`);
  } // It's a relative path. Prepend a forward slash.


  return normalizePath(`/${path}`);
}
/**
 * Return the last portion of a path. Similar to the Unix basename command.
 * @example Usage example
 *   path.basename('/foo/bar/baz/asdf/quux.html')
 *   // returns
 *   'quux.html'
 *
 *   path.basename('/foo/bar/baz/asdf/quux.html', '.html')
 *   // returns
 *   'quux'
 */

function basename(p, ext = '') {
  // Special case: Normalize will modify this to '.'
  if (p === '') {
    return p;
  } // Normalize the string first to remove any weirdness.


  p = normalizePath(p); // Get the last part of the string.

  const sections = p.split('/');
  const lastPart = sections[sections.length - 1]; // Special case: If it's empty, then we have a string like so: foo/
  // Meaning, 'foo' is guaranteed to be a directory.

  if (lastPart === '' && sections.length > 1) {
    return sections[sections.length - 2];
  } // Remove the extension, if need be.


  if (ext.length > 0) {
    const lastPartExt = lastPart.substr(lastPart.length - ext.length);

    if (lastPartExt === ext) {
      return lastPart.substr(0, lastPart.length - ext.length);
    }
  }

  return lastPart;
}
/**
 * Return the extension of the path, from the last '.' to end of string in the
 * last portion of the path. If there is no '.' in the last portion of the path
 * or the first character of it is '.', then it returns an empty string.
 * @example Usage example
 *   path.fileExtensionWithSeparator('index.html')
 *   // returns
 *   '.html'
 */

function fileExtensionWithSeparator(p) {
  p = normalizePath(p);
  const sections = p.split('/');
  p = sections.pop(); // Special case: foo/file.ext/ should return '.ext'

  if (p === '' && sections.length > 0) {
    p = sections.pop();
  }

  if (p === '..') {
    return '';
  }

  const i = p.lastIndexOf('.');

  if (i === -1 || i === 0) {
    return '';
  }

  return p.substr(i);
}
/**
 * Return the extension of the path, from after the last '.' to end of string in the
 * last portion of the path. If there is no '.' in the last portion of the path
 * or the first character of it is '.', then it returns an empty string.
 * @example Usage example
 *   path.fileExtension('index.html')
 *   // returns
 *   'html'
 */

function fileExtension(p) {
  const ext = fileExtensionWithSeparator(p);
  return ext === '' ? ext : ext.substr(1);
}

const filterPromises = (arr, filter) => Promise.all(arr.map(entry => filter(entry))).then(bits => arr.filter(() => bits.shift()));
const resolvePromiseProperties = obj => {
  // Get the keys which represent promises
  const promiseKeys = Object.keys(obj).filter(key => typeof obj[key].then === 'function');
  const promises = promiseKeys.map(key => obj[key]); // Resolve all promises

  return Promise.all(promises).then(resolvedPromises => // Return a copy of obj with promises overwritten by their
  // resolved values
  Object.assign({}, obj, zipObject(promiseKeys, resolvedPromises)));
};
const then = fn => p => Promise.resolve(p).then(fn);

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

const decodeParams = paramsString => List(paramsString.split('&')).map(s => List(s.split('=')).map(decodeURIComponent)).update(Map$1);

const fromURL = wholeURL => {
  const _wholeURL$split = wholeURL.split('?'),
        _wholeURL$split2 = _slicedToArray(_wholeURL$split, 2),
        url = _wholeURL$split2[0],
        allParamsString = _wholeURL$split2[1];

  return Map$1(_objectSpread({
    url
  }, allParamsString ? {
    params: decodeParams(allParamsString)
  } : {}));
};

const encodeParams = params => params.entrySeq().map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`).join('&');

const toURL = req => `${req.get('url')}${req.get('params') ? `?${encodeParams(req.get('params'))}` : ''}`;

const toFetchArguments = req => [toURL(req), req.delete('url').delete('params').toJS()];

const maybeRequestArg = req => {
  if (isString(req)) {
    return fromURL(req);
  }

  if (req) {
    return fromJS(req);
  }

  return Map$1();
};

const ensureRequestArg = func => req => func(maybeRequestArg(req));

const ensureRequestArg2 = func => (arg, req) => func(arg, maybeRequestArg(req)); // This actually performs the built request object


const performRequest = ensureRequestArg(req => fetch(...toFetchArguments(req))); // Each of the following functions takes options and returns another
// function that performs the requested action on a request. They each
// default to containing an empty object, so you can simply call them
// without arguments to generate a request with only those properties.

const getCurriedRequestProcessor = flow([ensureRequestArg2, curry]);

const getPropSetFunctions = path => [getCurriedRequestProcessor((val, req) => req.setIn(path, val)), getCurriedRequestProcessor((val, req) => req.getIn(path) ? req : req.setIn(path, val))];

const getPropMergeFunctions = path => [getCurriedRequestProcessor((obj, req) => req.updateIn(path, (p = Map$1()) => p.merge(obj))), getCurriedRequestProcessor((obj, req) => req.updateIn(path, (p = Map$1()) => Map$1(obj).merge(p)))];

const _getPropSetFunctions = getPropSetFunctions(['method']),
      _getPropSetFunctions2 = _slicedToArray(_getPropSetFunctions, 2),
      withMethod = _getPropSetFunctions2[0],
      withDefaultMethod = _getPropSetFunctions2[1];

const _getPropSetFunctions3 = getPropSetFunctions(['body']),
      _getPropSetFunctions4 = _slicedToArray(_getPropSetFunctions3, 2),
      withBody = _getPropSetFunctions4[0],
      withDefaultBody = _getPropSetFunctions4[1];

const _getPropMergeFunction = getPropMergeFunctions(['params']),
      _getPropMergeFunction2 = _slicedToArray(_getPropMergeFunction, 2),
      withParams = _getPropMergeFunction2[0],
      withDefaultParams = _getPropMergeFunction2[1];

const _getPropMergeFunction3 = getPropMergeFunctions(['headers']),
      _getPropMergeFunction4 = _slicedToArray(_getPropMergeFunction3, 2),
      withHeaders = _getPropMergeFunction4[0],
      withDefaultHeaders = _getPropMergeFunction4[1]; // withRoot sets a root URL, unless the URL is already absolute


const absolutePath$1 = new RegExp('^(?:[a-z]+:)?//', 'i');
const withRoot = getCurriedRequestProcessor((root, req) => req.update('url', p => {
  if (absolutePath$1.test(p)) {
    return p;
  }

  return root && p && p[0] !== '/' && root[root.length - 1] !== '/' ? `${root}/${p}` : `${root}${p}`;
})); // withTimestamp needs no argument and has to run as late as possible,
// so it calls `withParams` only when it's actually called with a
// request.

const withTimestamp = ensureRequestArg(req => withParams({
  ts: new Date().getTime()
}, req));
var unsentRequest = {
  toURL,
  fromURL,
  performRequest,
  withMethod,
  withDefaultMethod,
  withBody,
  withDefaultBody,
  withHeaders,
  withDefaultHeaders,
  withParams,
  withDefaultParams,
  withRoot,
  withTimestamp
};

const filterByPropExtension = (extension, propName) => arr => arr.filter(el => fileExtension(_get(el, propName)) === extension);

const catchFormatErrors = (format, formatter) => res => {
  try {
    return formatter(res);
  } catch (err) {
    throw new Error(`Response cannot be parsed into the expected format (${format}): ${err.message}`);
  }
};

const responseFormatters = fromJS({
  json: async res => {
    const contentType = res.headers.get('Content-Type');

    if (!contentType.startsWith('application/json') && !contentType.startsWith('text/json')) {
      throw new Error(`${contentType} is not a valid JSON Content-Type`);
    }

    return res.json();
  },
  text: async res => res.text(),
  blob: async res => res.blob()
}).mapEntries(([format, formatter]) => [format, catchFormatErrors(format, formatter)]);
const parseResponse = async (res, {
  expectingOk = true,
  format = 'text'
} = {}) => {
  if (expectingOk && !res.ok) {
    throw new Error(`Expected an ok response, but received an error status: ${res.status}.`);
  }

  const formatter = responseFormatters.get(format, false);

  if (!formatter) {
    throw new Error(`${format} is not a supported response format.`);
  }

  const body = await formatter(res);
  return body;
};
const responseParser = options => res => parseResponse(res, options);

/**
 * Simple script loader that returns a promise.
 */
function loadScript(url) {
  return new Promise((resolve, reject) => {
    let done = false;
    const head = document.getElementsByTagName('head')[0];
    const script = document.createElement('script');
    script.src = url;

    script.onload = script.onreadystatechange = function () {
      if (!done && (!this.readyState || this.readyState === 'loaded' || this.readyState === 'complete')) {
        done = true;
        resolve();
      } else {
        reject();
      }
    };

    script.onerror = error => reject(error);

    head.appendChild(script);
  });
}

export { APIError, Cursor, EditorialWorkflowError, localForage, unsentRequest, loadScript, CURSOR_COMPATIBILITY_SYMBOL, resolvePath, basename, fileExtensionWithSeparator, fileExtension, filterPromises, resolvePromiseProperties, then, filterByPropExtension, parseResponse, responseParser };

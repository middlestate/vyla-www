{"version":3,"sources":["../../src/redux/run-sift.js"],"names":["sift","require","_","prepareRegex","Promise","trackInlineObjectsInRootNode","getNode","getNodesByType","resolvedNodesCache","Map","enhancedNodeCache","enhancedNodePromiseCache","enhancedNodeCacheId","node","args","internal","contentDigest","JSON","stringify","nodeid","id","digest","nodesCache","loadNodes","type","nodes","process","env","NODE_ENV","has","get","set","siftifyArgs","object","newObject","each","v","k","isPlainObject","Minimatch","mm","makeRe","extractFieldsToSift","filter","Object","keys","reduce","acc","key","value","parseFilter","siftArgs","fieldsToSift","push","isEqId","firstOnly","length","awaitSiftField","fields","field","resolve","fieldName","undefined","resolveRecursive","siftFieldsObj","gqFields","all","map","then","innerSift","innerGqConfig","isObject","isFunction","getFields","isArray","ofType","item","resolvedFields","myNode","forEach","resolveNodes","typeName","gqlFields","nodesCacheKey","nodesLength","cacheKey","enhancedNodeGenerationPromise","resolvedNode","resolvedNodes","handleFirst","index","isEmpty","indexOf","$and","handleMany","sort","result","convertedFields","replace","orderBy","order","module","exports","queryArgs","gqlType","clonedArgs","parse","name"],"mappings":"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","sourcesContent":["// @flow\nconst sift = require(`sift`)\nconst _ = require(`lodash`)\nconst prepareRegex = require(`../utils/prepare-regex`)\nconst Promise = require(`bluebird`)\nconst { trackInlineObjectsInRootNode } = require(`../db/node-tracking`)\nconst { getNode, getNodesByType } = require(`../db/nodes`)\n\nconst resolvedNodesCache = new Map()\nconst enhancedNodeCache = new Map()\nconst enhancedNodePromiseCache = new Map()\nconst enhancedNodeCacheId = ({ node, args }) =>\n  node && node.internal && node.internal.contentDigest\n    ? JSON.stringify({\n        nodeid: node.id,\n        digest: node.internal.contentDigest,\n        ...args,\n      })\n    : null\n\nconst nodesCache = new Map()\n\nfunction loadNodes(type) {\n  let nodes\n  // this caching can be removed if we move to loki\n  if (process.env.NODE_ENV === `production` && nodesCache.has(type)) {\n    nodes = nodesCache.get(type)\n  } else {\n    nodes = getNodesByType(type)\n    nodesCache.set(type, nodes)\n  }\n  return nodes\n}\n\n/////////////////////////////////////////////////////////////////////\n// Parse filter\n/////////////////////////////////////////////////////////////////////\n\nfunction siftifyArgs(object) {\n  const newObject = {}\n  _.each(object, (v, k) => {\n    if (_.isPlainObject(v)) {\n      if (k === `elemMatch`) {\n        k = `$elemMatch`\n      }\n      newObject[k] = siftifyArgs(v)\n    } else {\n      // Compile regex first.\n      if (k === `regex`) {\n        newObject[`$regex`] = prepareRegex(v)\n      } else if (k === `glob`) {\n        const Minimatch = require(`minimatch`).Minimatch\n        const mm = new Minimatch(v)\n        newObject[`$regex`] = mm.makeRe()\n      } else {\n        newObject[`$${k}`] = v\n      }\n    }\n  })\n  return newObject\n}\n\n// Build an object that excludes the innermost leafs,\n// this avoids including { eq: x } when resolving fields.\nconst extractFieldsToSift = filter =>\n  Object.keys(filter).reduce((acc, key) => {\n    let value = filter[key]\n    let k = Object.keys(value)[0]\n    let v = value[k]\n    if (_.isPlainObject(value) && _.isPlainObject(v)) {\n      acc[key] =\n        k === `elemMatch` ? extractFieldsToSift(v) : extractFieldsToSift(value)\n    } else {\n      acc[key] = true\n    }\n    return acc\n  }, {})\n\n/**\n * Parse filter and returns an object with two fields:\n * - siftArgs: the filter in a format that sift understands\n * - fieldsToSift: filter with operate leaves (e.g { eq: 3 })\n *   removed. Used later to resolve all filter fields\n */\nfunction parseFilter(filter) {\n  const siftArgs = []\n  let fieldsToSift = {}\n  if (filter) {\n    _.each(filter, (v, k) => {\n      siftArgs.push(\n        siftifyArgs({\n          [k]: v,\n        })\n      )\n    })\n    fieldsToSift = extractFieldsToSift(filter)\n  }\n  return { siftArgs, fieldsToSift }\n}\n\n/////////////////////////////////////////////////////////////////////\n// Resolve nodes\n/////////////////////////////////////////////////////////////////////\n\nfunction isEqId(firstOnly, fieldsToSift, siftArgs) {\n  return (\n    firstOnly &&\n    Object.keys(fieldsToSift).length === 1 &&\n    Object.keys(fieldsToSift)[0] === `id` &&\n    Object.keys(siftArgs[0].id).length === 1 &&\n    Object.keys(siftArgs[0].id)[0] === `$eq`\n  )\n}\n\nfunction awaitSiftField(fields, node, k) {\n  const field = fields[k]\n  if (field.resolve) {\n    return field.resolve(\n      node,\n      {},\n      {},\n      {\n        fieldName: k,\n      }\n    )\n  } else if (node[k] !== undefined) {\n    return node[k]\n  }\n\n  return undefined\n}\n\n// Resolves every field used in the node.\nfunction resolveRecursive(node, siftFieldsObj, gqFields) {\n  return Promise.all(\n    _.keys(siftFieldsObj).map(k =>\n      Promise.resolve(awaitSiftField(gqFields, node, k))\n        .then(v => {\n          const innerSift = siftFieldsObj[k]\n          const innerGqConfig = gqFields[k]\n          if (\n            _.isObject(innerSift) &&\n            v != null &&\n            innerGqConfig &&\n            innerGqConfig.type\n          ) {\n            if (_.isFunction(innerGqConfig.type.getFields)) {\n              // this is single object\n              return resolveRecursive(\n                v,\n                innerSift,\n                innerGqConfig.type.getFields()\n              )\n            } else if (\n              _.isArray(v) &&\n              innerGqConfig.type.ofType &&\n              _.isFunction(innerGqConfig.type.ofType.getFields)\n            ) {\n              // this is array\n              return Promise.all(\n                v.map(item =>\n                  resolveRecursive(\n                    item,\n                    innerSift,\n                    innerGqConfig.type.ofType.getFields()\n                  )\n                )\n              )\n            }\n          }\n\n          return v\n        })\n        .then(v => [k, v])\n    )\n  ).then(resolvedFields => {\n    const myNode = {\n      ...node,\n    }\n    resolvedFields.forEach(([k, v]) => (myNode[k] = v))\n    return myNode\n  })\n}\n\nfunction resolveNodes(nodes, typeName, firstOnly, fieldsToSift, gqlFields) {\n  const nodesCacheKey = JSON.stringify({\n    // typeName + count being the same is a pretty good\n    // indication that the nodes are the same.\n    typeName,\n    firstOnly,\n    nodesLength: nodes.length,\n    ...fieldsToSift,\n  })\n  if (\n    process.env.NODE_ENV === `production` &&\n    resolvedNodesCache.has(nodesCacheKey)\n  ) {\n    return Promise.resolve(resolvedNodesCache.get(nodesCacheKey))\n  } else {\n    return Promise.all(\n      nodes.map(node => {\n        const cacheKey = enhancedNodeCacheId({\n          node,\n          args: fieldsToSift,\n        })\n        if (cacheKey && enhancedNodeCache.has(cacheKey)) {\n          return Promise.resolve(enhancedNodeCache.get(cacheKey))\n        } else if (cacheKey && enhancedNodePromiseCache.has(cacheKey)) {\n          return enhancedNodePromiseCache.get(cacheKey)\n        }\n\n        const enhancedNodeGenerationPromise = new Promise(resolve => {\n          resolveRecursive(node, fieldsToSift, gqlFields).then(resolvedNode => {\n            trackInlineObjectsInRootNode(resolvedNode)\n            if (cacheKey) {\n              enhancedNodeCache.set(cacheKey, resolvedNode)\n            }\n            resolve(resolvedNode)\n          })\n        })\n        enhancedNodePromiseCache.set(cacheKey, enhancedNodeGenerationPromise)\n        return enhancedNodeGenerationPromise\n      })\n    ).then(resolvedNodes => {\n      resolvedNodesCache.set(nodesCacheKey, resolvedNodes)\n      return resolvedNodes\n    })\n  }\n}\n\n/////////////////////////////////////////////////////////////////////\n// Run Sift\n/////////////////////////////////////////////////////////////////////\n\nfunction handleFirst(siftArgs, nodes) {\n  const index = _.isEmpty(siftArgs)\n    ? 0\n    : sift.indexOf(\n        {\n          $and: siftArgs,\n        },\n        nodes\n      )\n\n  if (index !== -1) {\n    return [nodes[index]]\n  } else {\n    return []\n  }\n}\n\nfunction handleMany(siftArgs, nodes, sort) {\n  let result = _.isEmpty(siftArgs)\n    ? nodes\n    : sift(\n        {\n          $and: siftArgs,\n        },\n        nodes\n      )\n\n  if (!result || !result.length) return null\n\n  // Sort results.\n  if (sort) {\n    // create functions that return the item to compare on\n    // uses _.get so nested fields can be retrieved\n    const convertedFields = sort.fields\n      .map(field => field.replace(/___/g, `.`))\n      .map(field => v => _.get(v, field))\n\n    // Gatsby's sort interface only allows one sort order (e.g `desc`)\n    // to be specified. However, multiple sort fields can be\n    // provided. This is inconsistent. The API should allow the\n    // setting of an order per field. Until the API can be changed\n    // (probably v3), we apply the sort order to the first field only,\n    // implying asc order for the remaining fields.\n    result = _.orderBy(result, convertedFields, [sort.order])\n  }\n  return result\n}\n\n/**\n * Filters a list of nodes using mongodb-like syntax.\n *\n * @param args raw graphql query filter as an object\n * @param nodes The nodes array to run sift over (Optional\n *   will load itself if not present)\n * @param type gqlType. Created in build-node-types\n * @param firstOnly true if you want to return only the first result\n *   found. This will return a collection of size 1. Not a single\n *   element\n * @returns Collection of results. Collection will be limited to size\n *   if `firstOnly` is true\n */\nmodule.exports = (args: Object) => {\n  const { queryArgs, gqlType, firstOnly = false } = args\n  // Clone args as for some reason graphql-js removes the constructor\n  // from nested objects which breaks a check in sift.js.\n  const clonedArgs = JSON.parse(JSON.stringify(queryArgs))\n\n  // If nodes weren't provided, then load them from the DB\n  const nodes = args.nodes || loadNodes(gqlType.name)\n\n  const { siftArgs, fieldsToSift } = parseFilter(clonedArgs.filter)\n\n  // If the the query for single node only has a filter for an \"id\"\n  // using \"eq\" operator, then we'll just grab that ID and return it.\n  if (isEqId(firstOnly, fieldsToSift, siftArgs)) {\n    return resolveRecursive(\n      getNode(siftArgs[0].id[`$eq`]),\n      fieldsToSift,\n      gqlType.getFields()\n    ).then(node => (node ? [node] : []))\n  }\n\n  return resolveNodes(\n    nodes,\n    gqlType.name,\n    firstOnly,\n    fieldsToSift,\n    gqlType.getFields()\n  ).then(resolvedNodes => {\n    if (firstOnly) {\n      return handleFirst(siftArgs, resolvedNodes)\n    } else {\n      return handleMany(siftArgs, resolvedNodes, clonedArgs.sort)\n    }\n  })\n}\n"],"file":"run-sift.js"}
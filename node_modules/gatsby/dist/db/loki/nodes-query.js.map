{"version":3,"sources":["../../../src/db/loki/nodes-query.js"],"names":["_","require","prepareRegex","getNodeTypeCollection","sift","emitter","fieldUsages","FIELD_INDEX_THRESHOLD","on","field","siftifyArgs","object","newObject","each","v","k","isPlainObject","Minimatch","mm","makeRe","runSift","nodes","query","siftQuery","$elemMatch","toMongoArgs","gqlFilter","lastFieldType","mongoArgs","obj","result","length","gqlFieldType","getFields","type","constructor","name","undefined","concat","dotNestedFields","acc","o","path","sample","forEach","trimStart","fixNeTrue","flattenedFields","transform","s","split","$or","$exists","$where","convertArgs","gqlArgs","gqlType","dottedFields","filter","toSortFields","sortArgs","fields","order","lokiSortFields","i","dottedField","replace","isDesc","lowerCase","push","ensureFieldIndexes","coll","lokiArgs","fieldName","update","n","get","ensureIndex","runQuery","queryArgs","context","firstOnly","JSON","parse","stringify","chain","find","sort","sortFields","sortField","compoundsort","data","module","exports"],"mappings":"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","sourcesContent":["const _ = require(`lodash`)\nconst prepareRegex = require(`../../utils/prepare-regex`)\nconst { getNodeTypeCollection } = require(`./nodes`)\nconst sift = require(`sift`)\nconst { emitter } = require(`../../redux`)\n\n// Cleared on DELETE_CACHE\nconst fieldUsages = {}\nconst FIELD_INDEX_THRESHOLD = 5\n\nemitter.on(`DELETE_CACHE`, () => {\n  for (var field in fieldUsages) {\n    delete fieldUsages[field]\n  }\n})\n\n// Takes a raw graphql filter and converts it into a mongo-like args\n// object that can be understood by the `sift` library. E.g `eq`\n// becomes `$eq`\nfunction siftifyArgs(object) {\n  const newObject = {}\n  _.each(object, (v, k) => {\n    if (_.isPlainObject(v)) {\n      if (k === `elemMatch`) {\n        k = `$elemMatch`\n      }\n      newObject[k] = siftifyArgs(v)\n    } else {\n      // Compile regex first.\n      if (k === `regex`) {\n        newObject[`$regex`] = prepareRegex(v)\n      } else if (k === `glob`) {\n        const Minimatch = require(`minimatch`).Minimatch\n        const mm = new Minimatch(v)\n        newObject[`$regex`] = mm.makeRe()\n      } else {\n        newObject[`$${k}`] = v\n      }\n    }\n  })\n  return newObject\n}\n\n// filter nodes using the `sift` library. But isn't this a loki query\n// file? Yes, but we need to support all functionality provided by\n// `run-sift`, and there are some operators that loki can't\n// support. Like `elemMatch`, so for those fields, we fall back to\n// sift\nfunction runSift(nodes, query) {\n  if (nodes) {\n    const siftQuery = {\n      $elemMatch: siftifyArgs(query),\n    }\n    return sift(siftQuery, nodes)\n  } else {\n    return null\n  }\n}\n\n// Takes a raw graphql filter and converts it into a mongo-like args\n// object that can be understood by loki. E.g `eq` becomes\n// `$eq`. gqlFilter should be the raw graphql filter returned from\n// graphql-js. e.g gqlFilter:\n//\n// {\n//   internal: {\n//     type: {\n//       eq: \"TestNode\"\n//     },\n//     content: {\n//       glob: \"et\"\n//     }\n//   },\n//   id: {\n//     glob: \"12*\"\n//   }\n// }\n//\n// would return\n//\n// {\n//   internal: {\n//     type: {\n//       $eq: \"TestNode\"  // append $ to eq\n//     },\n//     content: {\n//       $regex: new MiniMatch(v) // convert glob to regex\n//     }\n//   },\n//   id: {\n//     $regex: // as above\n//   }\n// }\nfunction toMongoArgs(gqlFilter, lastFieldType) {\n  const mongoArgs = {}\n  _.each(gqlFilter, (v, k) => {\n    if (_.isPlainObject(v)) {\n      if (k === `elemMatch`) {\n        // loki doesn't support elemMatch, so use sift (see runSift\n        // comment above)\n        mongoArgs[`$where`] = obj => {\n          const result = runSift(obj, v)\n          return result && result.length > 0\n        }\n      } else {\n        const gqlFieldType = lastFieldType.getFields()[k].type\n        mongoArgs[k] = toMongoArgs(v, gqlFieldType)\n      }\n    } else {\n      // Compile regex first.\n      if (k === `regex`) {\n        mongoArgs[`$regex`] = prepareRegex(v)\n      } else if (k === `glob`) {\n        const Minimatch = require(`minimatch`).Minimatch\n        const mm = new Minimatch(v)\n        mongoArgs[`$regex`] = mm.makeRe()\n      } else if (\n        k === `in` &&\n        lastFieldType &&\n        lastFieldType.constructor.name === `GraphQLList`\n      ) {\n        mongoArgs[`$containsAny`] = v\n      } else if (\n        k === `nin` &&\n        lastFieldType.constructor.name === `GraphQLList`\n      ) {\n        mongoArgs[`$containsNone`] = v\n      } else if (k === `ne` && v === null) {\n        mongoArgs[`$ne`] = undefined\n      } else if (k === `nin` && lastFieldType.name === `Boolean`) {\n        mongoArgs[`$nin`] = v.concat([false])\n      } else {\n        mongoArgs[`$${k}`] = v\n      }\n    }\n  })\n  return mongoArgs\n}\n\n// Converts a nested mongo args object into a dotted notation. acc\n// (accumulator) must be a reference to an empty object. The converted\n// fields will be added to it. E.g\n//\n// {\n//   internal: {\n//     type: {\n//       $eq: \"TestNode\"\n//     },\n//     content: {\n//       $regex: new MiniMatch(v)\n//     }\n//   },\n//   id: {\n//     $regex: newMiniMatch(v)\n//   }\n// }\n//\n// After execution, acc would be:\n//\n// {\n//   \"internal.type\": {\n//     $eq: \"TestNode\"\n//   },\n//   \"internal.content\": {\n//     $regex: new MiniMatch(v)\n//   },\n//   \"id\": {\n//     $regex: // as above\n//   }\n// }\nfunction dotNestedFields(acc, o, path = ``) {\n  if (_.isPlainObject(o)) {\n    if (_.isPlainObject(_.sample(o))) {\n      _.forEach(o, (v, k) => {\n        dotNestedFields(acc, v, path + `.` + k)\n      })\n    } else {\n      acc[_.trimStart(path, `.`)] = o\n    }\n  }\n}\n\n// The query language that Gatsby has used since day 1 is `sift`. Both\n// sift and loki are mongo-like query languages, but they have some\n// subtle differences. One is that in sift, a nested filter such as\n// `{foo: {bar: {ne: true} } }` will return true if the foo field\n// doesn't exist, is null, or bar is null. Whereas loki will return\n// false if the foo field doesn't exist or is null. This ensures that\n// loki queries behave like sift\nfunction fixNeTrue(flattenedFields) {\n  return _.transform(flattenedFields, (result, v, k) => {\n    if (v[`$ne`] === true) {\n      const s = k.split(`.`)\n      if (s.length > 1) {\n        result[s[0]] = {\n          $or: [\n            {\n              $exists: false,\n            },\n            {\n              $where: obj => obj === null || obj[s[1]] !== true,\n            },\n          ],\n        }\n        return result\n      }\n    }\n    result[k] = v\n    return result\n  })\n}\n\n// Converts graphQL args to a loki filter\nfunction convertArgs(gqlArgs, gqlType) {\n  const dottedFields = {}\n  dotNestedFields(dottedFields, toMongoArgs(gqlArgs.filter, gqlType))\n  return fixNeTrue(dottedFields)\n}\n\n// Converts graphql Sort args into the form expected by loki, which is\n// a vector where the first value is a field name, and the second is a\n// boolean `isDesc`. Nested fields delimited by `___` are replaced by\n// periods. E.g\n//\n// {\n//   fields: [ `frontmatter___date`, `id` ],\n//   order: `desc`\n// }\n//\n// would return\n//\n// [ [ `frontmatter.date`, true ], [ `id`, false ] ]\n//\n// Note that the GraphQL Sort API provided by Gatsby doesn't allow the\n// order to be specified per field. The sift implementation uses\n// lodash `orderBy`, but only applies the sort order to the first\n// field. So we do the same here\nfunction toSortFields(sortArgs) {\n  const { fields, order } = sortArgs\n  const lokiSortFields = []\n  for (let i = 0; i < fields.length; i++) {\n    const dottedField = fields[i].replace(/___/g, `.`)\n    const isDesc = i === 0 ? _.lowerCase(order) === `desc` : false\n    lokiSortFields.push([dottedField, isDesc])\n  }\n  return lokiSortFields\n}\n\n// Every time we run a query, we increment a counter for each of its\n// fields, so that we can determine which fields are used the\n// most. Any time a field is seen more than `FIELD_INDEX_THRESHOLD`\n// times, we create a loki index so that future queries with that\n// field will execute faster.\nfunction ensureFieldIndexes(coll, lokiArgs) {\n  _.forEach(lokiArgs, (v, fieldName) => {\n    // Increment the usages of the field\n    _.update(fieldUsages, fieldName, n => (n ? n + 1 : 1))\n    // If we have crossed the threshold, then create the index\n    if (_.get(fieldUsages, fieldName) === FIELD_INDEX_THRESHOLD) {\n      // Loki ensures that this is a noop if index already exists. E.g\n      // if it was previously added via a sort field\n      coll.ensureIndex(fieldName)\n    }\n  })\n}\n\n/**\n * Runs the graphql query over the loki nodes db.\n *\n * @param {Object} args. Object with:\n *\n * {Object} gqlType: built during `./build-node-types.js`\n *\n * {Object} queryArgs: The raw graphql query as a js object. E.g `{\n * filter: { fields { slug: { eq: \"/somepath\" } } } }`\n *\n * {Object} context: The context from the QueryJob\n *\n * {boolean} firstOnly: Whether to return the first found match, or\n * all matching results\n *\n * @returns {promise} A promise that will eventually be resolved with\n * a collection of matching objects (even if `firstOnly` is true)\n */\nasync function runQuery({ gqlType, queryArgs, context = {}, firstOnly }) {\n  // Clone args as for some reason graphql-js removes the constructor\n  // from nested objects which breaks a check in sift.js.\n  const gqlArgs = JSON.parse(JSON.stringify(queryArgs))\n  const lokiArgs = convertArgs(gqlArgs, gqlType)\n  const coll = getNodeTypeCollection(gqlType.name)\n  ensureFieldIndexes(coll, lokiArgs)\n  let chain = coll.chain().find(lokiArgs, firstOnly)\n\n  if (gqlArgs.sort) {\n    const sortFields = toSortFields(gqlArgs.sort)\n\n    // Create an index for each sort field. Indexing requires sorting\n    // so we lose nothing by ensuring an index is added for each sort\n    // field. Loki ensures this is a noop if the index already exists\n    for (const sortField of sortFields) {\n      coll.ensureIndex(sortField[0])\n    }\n    chain = chain.compoundsort(sortFields)\n  }\n\n  return chain.data()\n}\n\nmodule.exports = runQuery\n"],"file":"nodes-query.js"}